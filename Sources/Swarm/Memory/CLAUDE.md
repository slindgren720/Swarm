<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>

# Memory Module

## Overview

The memory module provides pluggable memory systems for agents — from simple conversation buffers to semantic retrieval and LLM-compressed summaries. All implementations are actors for thread safety.

## Core Protocol

```swift
public protocol Memory: Actor, Sendable {
    var count: Int { get async }
    var isEmpty: Bool { get async }
    func add(_ message: MemoryMessage) async
    func context(for query: String, tokenLimit: Int) async -> String
    func allMessages() async -> [MemoryMessage]
    func clear() async
}
```

## Memory Types

| Type | Strategy | Use When |
|------|----------|----------|
| `ConversationMemory` | Fixed-capacity rolling buffer | Simple chat, low-latency, no embedding needed |
| `VectorMemory` | Embedding-based semantic retrieval | Long-term knowledge retrieval, relevant context selection |
| `SummaryMemory` | LLM-compressed conversation history | Long conversations that need full context without token bloat |
| `HybridMemory` | Combines multiple strategies | Multi-stage retrieval (e.g., recent + semantic) |
| `SwiftDataMemory` | Persistent via SwiftData | App restart survival, long-term storage |

## Key Types

### MemoryMessage
```swift
enum MemoryMessage {
    case user(String)
    case assistant(String)
    case system(String)
    case tool(name: String, result: String)
}
```
Provides `formattedContent` for context building.

### TokenEstimator
Protocol for estimating token counts within context budgets.
Default: `CharacterBasedTokenEstimator` (simple character-based approximation).

### AnyMemory
Type-erased wrapper enabling polymorphic memory handling. Captures protocol methods as stored closures.

## Implementation Pattern

```swift
public actor MyMemory: Memory {
    private var entries: [MemoryEntry] = []

    public var count: Int { entries.count }
    public var isEmpty: Bool { entries.isEmpty }

    public func add(_ message: MemoryMessage) {
        entries.append(MemoryEntry(message: message))
    }

    public func context(for query: String, tokenLimit: Int) -> String {
        // Select relevant entries within token budget
        formatMessagesForContext(selectedEntries, tokenLimit: tokenLimit)
    }

    public func allMessages() -> [MemoryMessage] {
        entries.map(\.message)
    }

    public func clear() {
        entries.removeAll()
    }
}
```

## Conventions
- All memory implementations MUST be `actor` types
- Use `Log.memory` for logging
- `context(for:tokenLimit:)` must respect token budget — work backwards from most recent
- Memory is injected via `AgentConfiguration` or `@Environment(\.memory)`
- Test with `MockAgentMemory` from `Tests/SwarmTests/Mocks/`
