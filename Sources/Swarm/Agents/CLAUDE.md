<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

### Feb 9, 2026

| ID | Time | T | Title | Read |
|----|------|---|-------|------|
| #995 | 12:58 AM | ðŸ”µ | Agent Implements Tool-Calling with Provider Resolution Cascade | ~492 |
</claude-mem-context>

# Agents Module

## Overview

The agents module contains concrete agent implementations that conform to `AgentRuntime`. Each agent type represents a different execution strategy for LLM-powered task completion.

## Core Protocol

```swift
public protocol AgentRuntime: AnyObject {
    var tools: [any AnyJSONTool] { get }
    var instructions: String { get }
    var configuration: AgentConfiguration { get }
    var memory: (any Memory)? { get }
    var inferenceProvider: (any InferenceProvider)? { get }
    var tracer: (any Tracer)? { get }
    func run(_ input: String, session: (any Session)?, hooks: (any RunHooks)?) async throws -> AgentResult
    func stream(_ input: String, session: (any Session)?, hooks: (any RunHooks)?) -> AsyncThrowingStream<AgentEvent, Error>
    func cancel() async
}
```

## Agent Types

### Agent (Structured Tool Calling)
- **Strategy**: Uses `generateWithToolCalls()` for reliable, structured tool invocation
- **Loop**: Build prompt â†’ call provider with tool schemas â†’ execute tools â†’ add results â†’ repeat until no tool calls
- **Provider resolution**: Explicit â†’ Environment â†’ Foundation Models â†’ Error
- **File**: `Agent.swift`

### ReActAgent (Reasoning + Acting)
- **Strategy**: Thought-Action-Observation text parsing loop
- **Loop**: Think â†’ parse tool call from text â†’ execute tool â†’ observe result â†’ think again
- **Best for**: When structured tool calling isn't available
- **File**: `ReActAgent.swift`

### PlanAndExecuteAgent (Three-Phase)
- **Strategy**: Plan decomposition â†’ execute steps â†’ replan on failure
- **Phases**: Planning â†’ Execution â†’ Replanning
- **Key types**: `ExecutionPlan`, `PlanStep`, `StepStatus`
- **File**: `PlanAndExecuteAgent.swift`

## Shared Properties (from AgentRuntime)
- `tools: [any AnyJSONTool]` â€” available tools
- `instructions: String` â€” system prompt
- `configuration: AgentConfiguration` â€” runtime settings
- `memory: (any Memory)?` â€” memory system
- `inferenceProvider: (any InferenceProvider)?` â€” LLM provider
- `inputGuardrails / outputGuardrails` â€” validation
- `tracer: (any Tracer)?` â€” observability
- `handoffs: [AnyHandoffConfiguration]` â€” multi-agent delegation

## Implementation Pattern

```swift
public actor MyAgent: AgentRuntime {
    nonisolated public let tools: [any AnyJSONTool]
    nonisolated public let instructions: String
    nonisolated public let configuration: AgentConfiguration

    public func run(_ input: String, session: (any Session)?, hooks: (any RunHooks)?) async throws -> AgentResult {
        let builder = AgentResult.Builder()
        builder.start()
        // ... execution loop ...
        return builder.setOutput(finalOutput).build()
    }
}
```

## Conventions
- All agent types MUST be `actor` for thread safety
- Use `nonisolated` for immutable properties set at init
- Use `Log.agents` for logging
- Provider resolution follows cascade: explicit â†’ environment â†’ Foundation Models
- Results use `AgentResult.Builder()` for accumulation
- Handoff support via `findHandoffConfiguration()` and `applyHandoffConfiguration()`
